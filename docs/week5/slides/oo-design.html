<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Objektorientiertes Design</title>

	<link rel="stylesheet" href="../../slides/css/reveal.css">
	<link rel="stylesheet" href="../../slides/css/theme/unibas.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="../../slides/lib/css/zenburn.css">

	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? '../../slides/css/print/pdf.css' : '../../slides/css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<div class="reveal">
		<div class="slides">

			<section class="center">
				<div class="titleblock">

					<p>
						<img class="plain" src="../../slides/images/uni-basel-logo.png" style="width:15%;float:left;display:block" />
					</p>


					<h1 style="clear:both;margin-top:20%">
						Objektorientiertes Design und Programmierung

					</h1>
					<h3>
						Marcel L&uuml;thi <br> Departement Mathematik und Informatik
					</h3>

                </div>
                
                <aside class="notes">
                    Willkommen zu diesem Screencast zum Thema OO-Design. 
                    Die Konzepte der Objektorientierung, und  bereits erste objektorientierte Programmiersprachen wurden bereits in den 
                    70er Jahren entwickelt. 
                    Es hat zwei Jahrzehnte gedauert, bis das Konzept in der Industrie angelangt ist. 
                    Seit den 90er Jahren ist OO Programmierung 
                    jedoch das dominierende Prinzip in der Softwareentwicklung. 
                    Dieses Konzept wollen wir uns im folgenden etwas näher anschauen. 
                </aside>

			</section>

            <section>
                <h1>Objektorientierte Programmiersprachen</h1>

                <img src="../../slides/images/oo-pls.png" class="plain"/>

                <aside class="notes">
                    Die meisten der populären Programmiersprachen, von c++ Über Java, C# bis hin zu Scriptsprachen wie Python, 
                    unterstützen Objektorientierte Konzepte. In einigen Programmiersprachen wie zum Beispiel Smalltalk, oder Ruby, ist das 
                    Konzept so zentral das wirklcih alles, was man in diesen Sprachen repreaesentiern kann einem Objekt entspricht.
                </aside>
            </section>



            <section>
                <h1>Objektorientierte Design</h1>
            
                <blockquote>
                        <p style="font-size:smaller">“Pertaining to a technique or a programming language that supports objects, classes, and inheritance.” </p>
                        <p style="text-align:right;font-size: smaller;display:block"> ISO/IEC 2382-15</p>
                </blockquote>

                <blockquote class="fragment">
                        <p style="font-size:smaller">“OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things.”</p>
                        <p style="text-align:right;font-size:smaller;display:block"> A. Kay</p>
                    </blockquote>
            <aside class="notes">
                Entsprechend den Sprachen wird auch das Softwaredesign objektorientiert gedacht. Nur, was ist denn eigentlich objekt-orientiert?
                Dier erste Definition ist eine etwas technische ISO definition. Die Definition sagt einfach, dass man Objketorientiert arbietet, wenn 
                man eine Technik einsetzt, die Objekte, Klassen und Vererbung unterstützt. 
                Eine etwas nützlichere Definition wird von Alan Kay, einem der Väter der Objektorientierung gebeben. 
                Es sagt, dass es bei der Objektorientierte Programmierung vor allem um die Kommunikation zwischen Objekten geht. 
                Objekte sollen nur via Nachrichten kommunizieren, und ihren Zustand nur lokal, also intern, halten  und 
                nicht nach aussen preisgeben. Das entspricht wieder dem Information hiding. 
                Ausserdem, soll erst so spät we möglich entschieden werden, welches Objekt den genau eine Anfrage bearbeitet. Wir kommen später 
                nochmals genauer auf diese Definition zurück.
            </aside>


            </section>


            <section>
                <h1>Design und Programmiersprache</h1>
                <blockquote>
                    Wichtig beim OO Design sind Prinzipien (Information Hiding, Modularisierung, late binding), nicht die Programmiersprache.
                </blockquote>
                <div style="float:left;width:60%">
                    <ul>
                        <li>OO Sprachen helfen Design direkt abzubilden</li>
                        <li>Nicht OO Sprachen verlangen Mehraufwand / Disziplin</li>
                    </ul>
                </div>
                <div style="float:right;width:40%">
                    <figure>
                        <img src="../../slides/images/gtk3-widget.png" class = "plain"/>
                        <figcaption style="font-size:x-small">By <a href="//commons.wikimedia.org/w/index.php?title=User:%D7%99%D7%95%D7%A1%D7%A3_%D7%90%D7%95%D7%A8&amp;action=edit&amp;redlink=1"
                                class="new" title="User:יוסף אור (page does not exist)">יוסף אור</a> - <span class="int-own-work"
                                lang="en">Own work</span>, <a href="http://www.gnu.org/licenses/lgpl.html" title="GNU Lesser General Public License">LGPL</a>,
                            <a href="https://commons.wikimedia.org/w/index.php?curid=39205896">Link</a> </figcaption>
                    </figure>
                </div>
                <div style="text-align:left;display:block">
                <ul>                     
                    <li>Gutes Beispiel für OO Design in C: <a href="https://en.wikipedia.org/wiki/GTK%2B">GTK+</a></li>
                </ul>
            </div>

            <aside class="notes">
                Als erstes wollen wir aber feststellen, dass Objektorientierung nicht unbedingt an eine Programmiersprache gebunden sein muss. 
                Das wichtige sind auch hier die Konzepte wie Information Hiding, Modularisierung oder eben diese Late binding. Objektorientierte Programmiersprache helfen uns, diese 
                Konzepte umzusetzen. Mit etwas Mehraufwand und Disziplin kann ich jedoch in jeder Programmiersprache Objektorientiert programmieren. 
                Ein Gutes Beispiel hierfür ist GTK+. Dieses Windowing Toolkit ist in C geschrieben. Es ist aber komplett nach Objektorientierten Prinzipien designed. 
                Das macht auch sinn, da die stärke von Objektorientierung genau das Modularisieren und Kapseln von Objektzuständen ist. Und genau solche hat man bei der GUI Entwicklung sehr viel. 
            </aside>

            </section>


            <section>
                <h1>Terminologie</h1>
                <ul>
                    <li>
                        <mark class="highlight">Klasse</mark> implementiert Abstrakten Datentyp</li>                        
                        <li> Daten heissen <mark class="highlight">Attribute </mark> </li>
                        <li><mark class="highlight">Konstruktor</mark> kreiert neue Instanzen</li>
                
                        <li>Operationen heissen
                                <mark class="highlight">Methoden</mark>
                            </li>
                        <li><mark class="highlight">Instanzvariablen</mark> sind Referenzen auf Objekte</li>
                        <li><mark class="highlight">Laufzeitstruktur</mark> die Menge der Objekte zur Laufzeit</li>
                        <ul><li>Jedes Objekt ist zur Laufzeit eindeutig identifiziert</li></ul>
                    </li>                        
                </ul>
                
                <aside class="notes">
                    Bevor wir uns näher mit Objektorientiertem Design beschäftigen, müssen wir zuerst etwas Terminologie klären. 
                    Das wichtigste Konzept ist eine Klasse. Im Prinzip ist eine Klasse einfach eine Implementation eines Abstrakten Datentyps. 
                    Die Funktion, um neue Objekte, also Instanzen der Klasse zu generieren, wird Konstruktor genannt. 
                    In der OO Terminologie werden die Daten eines Objekts als Attribute bezeichnet und die Operationen die auf diesen DAten arbeiten nennt 
                    man Methoden. 
                    Um überhaupt mit einem Objekt arbeiten zu können muss ich eine Referenz auf ein Objekt haben. Eine Variable die eine solche Referenz speichert wird
                    Instanzvariable genannt. 
                    Als Laufzeitstruktur bezeichnen wir die Menge aller Objekte, die zur Laufzeit existieren. 
                    Jedes Objekt in dieser Laufzeitstruktur hat eine eigene ID, kann also eindeutig identifiziert werden. 
                </aside>
            </section>

            <section>
                <h1>Schnittstellen</h1>

                <blockquote>
                    Nutzung der Funktionalität eines Objekts nur über wohldefinierte Schnittstellen.
                </blockquote>
                <ul>    
                    <li> Mehrere Objekte können gleiche Schnittstelle anbieten
                    <li> Ein Objekt kann mehrere Schnittstellen anbieten</li>
                </ul
                >
                <div style="text-align:left; display:block; margin-top:1cm">
                Beispiel aus Java: 

                <pre><code data-trim class="java"> 
                    public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
                            implements List&lt;E&gt;, 
                            RandomAccess
                    </code></pre>
                </div>                

                <aside class="notes">
                    Wie wir bei den allgemeinen Prinzipien zum Modul design gesehen haben, sollen Module ihre Dienste immer via Schnittstellen anbieten. 
                    Diesem Prinzip wird auch in der OO Programmierung gefolgt. Die Beziehung hier ist aber nicht eins zu eins. Eine Schnittstelle kann von 
                    mehreren Objekten angeboten werden. Auch kann dasselbe Objekt mehrere Schnittstellen anbieten. 
                    Zum beispiel gibt es in Java die Klasse ArrayList. Diese Klasse kann von einem Client sowohl als Liste verwendet werdne, 
                    oder aber auch als Sequenz mit wahlfreiem Zugriff auf die Elemente, je nachdem welche Schnittstelle verwendet wird. Die Implementation 
                    ist jedoch immer dieselbe.
                    Es ist natürlich auch möglich, das eine Schnittstelle von verschiedenen Objekten Implementiert ist. So gibt es in Java nicht nur die Klasse
                    ArrayList die das List interface implementiert, sondern auch die Klasse Linked List. 
                    
                </aside>
            </section>


            <section>
                    <h1> Dynamische Bindung und Polymorphismus</h1>
                    <ul>
                        <li><mark class="highlight">Polymorphismus:</mark> Variablen k&ouml;nnen zur Laufzeit an verschiedene (verwandte) Typen gebunden werden</li>                                               
                        <li><mark class="highlight">Dynamische Bindung (late binding):</mark> Zur Laufzeit wird Methode entsprechend dem Objekttyp verwendet. </li>
                    </ul>
                    <aside class="notes">
                        Dies führt uns zur letzten wichtigen Eigenschaft von Objektorientierten Systemen, nämlich der Dynamische Bindung, 
                        auf English Late Binding genannt. Die Idee dahinter ist, das wenn mehrere Objekte dieselbe Schnittstelle anbieten, 
                        dass dann erst zur Laufeit entschieden wird, welches Objekt eine Anfrage bearbeitet. 
                        Die ist möglich, da eine instanzvarible unterschiedliche Typen repräsentieren kann. 
                        Diese Fähigkeit nennt Polymorphismus, und ist ein wichtiges Merkmal von Objektorientierten Sprachen. 
                  
                    </aside>
                </section>            
                <section> <h1>Beispiel: Polymorphismus </h1>
                    <pre><code data-trim class="java" style="font-size:smaller;line-height:2ch"> 
                        interface Foo {
                            public void bar();
                        }
                        class FooImpl1 implements Foo { 
                            public void bar() { System.out.println("in FooImpl1"); }
                        }
                        class FooImpl2 implements Foo { 
                            public void bar() { System.out.println("in FooImpl2"); }
                        }
                        void doSomethingWithFoo(Foo foo) {
                            foo.bar();
                        }
                                                 
                        if (condition) 
                            doSomethingWithFoo(new FooImpl1()) 
                        else 
                            doSomethingWithFoo(new FooImpl2())
                    </code></pre> 
    
                    <ul>
                        <li>Unterschiedliche Ausgabe je nachdem ob 
                            <text style="font-family:Courier New, Courier, monospace">foo</text> an
                            <text style="font-family:Courier New, Courier, monospace">FooImpl1 </text> oder
                            <text style="font-family:Courier New, Courier, monospace">FooImpl2</text> gebunden wird.</li>
                    </ul>
                    
                    <aside class="notes">
                        Wir wollen das an einem Beispiel illustrieren.
                        In diesem Beispiel haben wir eine Schnittstelle Foo, die verlangt, dass die Methode bar implementiert wird. 
                        Dazu haben wir zwei Klassen, FooImpl1 und FooImpl2, welche diese Schnittstelle implementieren. 
                        Zusätzlich haben wir auch noch eine Methode doSomethingWithFoo, die ein Objekt vom Typ Foo als Argument nimmt,
                         ohne jedoch zu sagen ob es FooImpl1 oder FooImpl2 sein soll. 
                        Late binding macht es möglich, dass in der Methode erst zur Laufzeit entschieden wird,
                         ob die bar Methode vom Objekt FooImpl2, oder FooImpl1 genutzt wird, je nachdem, welches Objekt übergeben wird. 
                        

                    </aside>
                </section>

                <section>
                        <h1>Objektorientierung als "Messaging"</h1>
                        
                        <div style="float:left;width:60%">
                        <ul>
                            <li>Objekte verwalten Zustand der Daten (Attribute)</li>
                            <li>Nehmen Nachrichten/Requests entgegen (Methoden)</li> 
                            <li>Senden Antwort zur&uuml;ck und/oder ver&auml;ndern Zustand</li>
                   </ul>
                   </div>

                   <div style="float:right;width:40%">
                    <img src="../../slides/images/island.png" style="width:100%" class="plain">
                    <figcaption style="font-size:xx-small">Gabriel VanHelsing, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=7560534</figcaption>
 
                    
                    </div>
                   <blockquote style="display:inline-block">
                        Methodenaufruf = senden einer Nachricht       
                </blockquote>                    
                <aside class="notes">
                    Eine hilfreiche sicht auf die Objektorientierung ist, dass wir uns die Objekte als Inseln vorstellen mit 
                    der wir nur via Nachrichten kommunizieren können. Alle Daten vom Objekt verlassen nie diese Insel.  
                    Wenn wir nun eine Dienstleistung von dem Objekt in Anspruch nehmen wollen, 
                    können wir eine Nachricht senden. Dieses Senden der Nachricht entspricht einem Methodenaufruf. 
                    Daraufhin passiert etwas mit dem Objekt, es führt  zum Beispiel eine Berechnung durch, oder 
                    verändert seinen internen Zustand (also die DAten). Das Objekt sendet als Antwort wieder ein 
                    Nachricht an das Aufrufende Objekt zurück. Die Daten bleiben dabei aber immer auf der Insel und werden nur lokal verändert. 

                    Das ist konsequentes Information hiding .
                    

                </aside>

                    </section>
        

            <section>
                    <h1>Beispiel: Methodenaufruf als Nachricht</h1>
                    <div style="float:left; width:60%; height:100%">
                    <pre><code  data-trim class="java" style="font-size:smaller;line-height:2ch">
                    class BankAccount { 
                      private FxConverter fx = new FxConverter();
                      private double balanceCHF;

                      void depositEur(double amount) { 
                        double asCHF = b.convertEurToCHF(amount))
                          this.updateBalance(balanceCHF + asCHF)
                      }
                      void updateBalance(double newBalance) {
                        balanceInCHF = newBalance;
                      }
                    }
                        
                    // somewhere in currentObject                         
                    someAccount.depositEUR(500);                        
                    </code></pre>
                </div>
                <div style="float:right; width:40%">
                    <img src="../../slides/images/oocommunication.png" class="plain"/>
                </div>
                </section>
    

      

            <section>
                <h1>OO Design - Zusammenfassung</h1>
                <ul>

                    <li>Aufteilen eines Systems in Module
                        <ul>
                            <li>Objekte verwalten Daten </li>                            
                            <li>Zugriff nur via Methoden</li>
                        </ul>
                        <li>Interpretation: Kommunikation via messaging</li>
                        <li> Late binding: Es wird erst zur Laufzeit entschieden welches Objekt Nachricht erhält/bearbeitet</li>                  
                </ul>
                <!--
                <blockquote>
                    Implementation der Prinzipien <mark class="highlight">Modularisierung</mark> und <mark class="highlight">Information Hiding</mark> 
                </blockquote>
            -->
                <aside class="notes">
                    Fassen wir zusammen: Im OO Design wird das System in Module aufgeteilt. Diese Module werden Klassen genannt. 
                    In den Instanzen von diesen Klassen, den Objekten, werden die Daten verwaltet. Zugriff auf diese Daten ist Nur
                    via Methoden möglich. Man kann das so interpretieren, dass ein Methodenaufrum dem Senden einer Nachricht an das
                    Objekt entspricht. Welches Objekt die Nachricht empfängt und bearbeitet, wird aber erst zur Laufzeit definiert. 
                    
                    Die Konsequente Anwendung dieser Mechanismen erlaubt es uns  klare, gute zu wartende und modulare Designs zu entwerfen. 
                </aside>

            </section>


            <!--
            <section>
                <h3>Unit Tests</h3>
                <ul>
                    <li>Nennen sie die wichtigsten Eigenschaften von OO Systemen?</li>
                    <li>Was ist Polymorphismus und weshalb ist es wichtig?</li>
                    <li>Erkl&auml;ren sie wie Objekte "kommunizieren"</li>
                    <li>Was ist das Problem von Vererbung</li>
                    <ul><li>Weshalb sollte Komposition bevorzugt werden?</li></ul>
            </ul>
            </section>
-->

        </div>
    </div>



 
	<script src="../../slides/lib/js/head.min.js"></script>
	<script src="../../slides/js/reveal.js"></script>

	<script>
		file: ///home/luetma00/documents/teaching/sweng/theory/lecture1/admin.html#/1
		// More info about config & dependencies:
		// - https://github.com/hakimel/reveal.js#configuration
		// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
			center: false,
            transition: 'none',           
            /* 
			chalkboard: {
				src: "chalkboard.json",
				readOnly: undefined,
				transition: 800,
				theme: "whiteboard",
				//toggleChalkboardButton: { left: "30px", bottom: "30px", top: "auto", right: "auto" },
				//toggleNotesButton: { left: "30px", bottom: "30px", top: "auto", right: "auto" },
				// configuration options for notes canvas and chalkboard
				color: ['rgba(0,0,255,1)', 'rgba(255,255,255,0.5)'],
				background: ['rgba(127,127,127,.1)', '../../slides/plugin/chalkboard/img/whiteboard.png'],
				pen: ['url(../../slides/plugin/chalkboard/img/boardmarker.png), auto', 'url(../../slides/plugin/chalkboard/img/boardmarker.png), auto'],
			},
            */
            math: {
					// mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
					config: 'TeX-AMS_HTML-full'
				},

			dependencies: [{
				src: '../../slides/plugin/markdown/marked.js'
			},
			{
				src: '../../slides/plugin/markdown/markdown.js'
			},
            { src: '../../slides/plugin/mouse-pointer/mouse-pointer.js', async: true }, 
			{
				src: '../../slides/plugin/notes/notes.js',
				async: true
			},
            /*
			{
				src: '../../slides/plugin/chalkboard/chalkboard.js'
			},
            */
			{
				src: '../../slides/plugin/highlight/highlight.js',
				async: true,
				callback: function () {
					hljs.initHighlightingOnLoad();
				}
			},
            { src: '../../slides/plugin/math/math.js', async: true }
            			],
			keyboard: {
                /*
				67: function () {
					RevealChalkboard.toggleNotesCanvas()
				}, // toggle notes canvas when 'c' is pressed
				66: function () {
					RevealChalkboard.toggleChalkboard()
				}, // toggle chalkboard when 'b' is pressed
				46: function () {
					RevealChalkboard.clear()
				}, // clear chalkboard when 'DEL' is pressed
				8: function () {
					RevealChalkboard.reset()
				}, // reset chalkboard data on current slide when 'BACKSPACE' is pressed
				68: function () {
					RevealChalkboard.download()
				}, // downlad recorded chalkboard drawing when 'd' is pressed
                */
			},
		});
	</script>
</body>

</html>